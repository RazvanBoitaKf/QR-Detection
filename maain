# main.py
import os
import cv2
import base64
import numpy as np
import onnxruntime as ort
import supervision as sv
import uuid

# ---------------- CONFIG ----------------
ID2NAME = {29: "collar", 32: "sleeve", 33: "pocket"}
TARGETS = set(ID2NAME.values())
MASK_THRESH = 0.5
SCORE_THRESH = 0.5
SHORT_SIDE = 800
ONNX_PATH = "C:/Users/eu/Downloads/facere_base.onnx"  # change if needed

# ---------------- SESSION ----------------
_ORT = ort.InferenceSession(ONNX_PATH, providers=["CPUExecutionProvider"])
_INPUT_NAME = _ORT.get_inputs()[0].name

# ---------------- HELPERS ----------------
def preprocess(frame_bgr: np.ndarray):
    rgb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
    h, w = rgb.shape[:2]
    scale = SHORT_SIDE / float(min(h, w))
    new_w, new_h = int(round(w * scale)), int(round(h * scale))
    resized = cv2.resize(rgb, (new_w, new_h), interpolation=cv2.INTER_LINEAR)
    x = resized.astype("float32") / 255.0
    x = np.transpose(x, (2, 0, 1))[None, ...]  # NCHW
    return x, (new_w, new_h)

def run_inference(img_bgr: np.ndarray):
    x, _ = preprocess(img_bgr)
    boxes, labels, scores, masks = _ORT.run(None, {_INPUT_NAME: x})

    xyxy_list, mask_list, conf_list, class_list, name_list = [], [], [], [], []

    N = int(len(scores))
    mask_sample = masks[0, 0]
    if not (0.0 <= float(mask_sample.min()) and float(mask_sample.max()) <= 1.0):
        masks = 1.0 / (1.0 + np.exp(-masks))  # sigmoid

    for i in range(N):
        conf = float(scores[i])
        if conf < SCORE_THRESH:
            continue

        cid = int(labels[i])
        cname = ID2NAME.get(cid, f"id:{cid}")
        if TARGETS and cname not in TARGETS:
            continue

        x1, y1, x2, y2 = [int(round(v)) for v in boxes[i]]
        m = masks[i, 0] > MASK_THRESH
        if not np.any(m):
            continue

        xyxy_list.append([x1, y1, x2, y2])
        mask_list.append(np.ascontiguousarray(m, dtype=bool))
        conf_list.append(conf)
        class_list.append(cid)
        name_list.append(cname)

    if xyxy_list:
        xyxy = np.asarray(xyxy_list, dtype=np.float32)
        mask = np.stack(mask_list, axis=0).astype(bool)
        confidence = np.asarray(conf_list, dtype=np.float32)
        class_id = np.asarray(class_list, dtype=np.int32)
    else:
        xyxy = np.empty((0, 4), dtype=np.float32)
        H, W = masks.shape[-2], masks.shape[-1]
        mask = np.zeros((0, H, W), dtype=bool)
        confidence = np.empty((0,), dtype=np.float32)
        class_id = np.empty((0,), dtype=np.int32)

    dets = sv.Detections(xyxy=xyxy, mask=mask, confidence=confidence, class_id=class_id)
    dets.data = {
        "detection_id": np.array([str(uuid.uuid4()) for _ in range(len(xyxy))], dtype=object),
        "class_name": np.array(name_list, dtype=object) if name_list else np.empty((0,), dtype=object),
    }
    return dets

def draw_predictions(img_bgr, preds: sv.Detections):
    overlay = img_bgr.copy()
    alpha = 0.45
    outline_thickness = 2

    for i in range(len(preds)):
        cls_name = preds.data["class_name"][i]
        conf = preds.confidence[i] if preds.confidence is not None else None
        color = tuple(int(c) for c in np.random.randint(0, 255, 3))

        # mask drawing
        if preds.mask is not None and len(preds.mask) > i and preds.mask[i] is not None:
            m = preds.mask[i].astype(bool)
            if m.shape != img_bgr.shape[:2]:
                m = cv2.resize(m.astype(np.uint8), (img_bgr.shape[1], img_bgr.shape[0]), interpolation=cv2.INTER_NEAREST).astype(bool)
            overlay[m] = (0.55*np.array(color) + 0.45*overlay[m]).astype(np.uint8)
            cnts, _ = cv2.findContours(m.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            for c in cnts:
                if len(c) >= 3:
                    cv2.polylines(overlay, [c], True, color, outline_thickness)

            # label
            ys, xs = np.where(m)
            if xs.size and ys.size:
                x, y, w, h = cv2.boundingRect(np.stack([xs, ys], axis=1).reshape(-1,1,2))
                text = f"{cls_name} {conf:.2f}" if conf is not None else cls_name
                cv2.putText(overlay, text, (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2, cv2.LINE_AA)

        elif preds.xyxy is not None and len(preds.xyxy) > i:
            x1,y1,x2,y2 = [int(v) for v in preds.xyxy[i]]
            cv2.rectangle(overlay, (x1,y1), (x2,y2), color, outline_thickness)
            text = f"{cls_name} {conf:.2f}" if conf is not None else cls_name
            cv2.putText(overlay, text, (x1, y1-5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2, cv2.LINE_AA)

    out = cv2.addWeighted(overlay, alpha, img_bgr, 1-alpha, 0)
    return out


def live_inference():
    cap = cv2.VideoCapture(0)  # 0 = default webcam
    if not cap.isOpened():
        raise RuntimeError("Could not open webcam")

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        preds = run_inference(frame)
        result = draw_predictions(frame, preds)

        cv2.imshow("Live Predictions", result)

        # Exit on 'q'
        if cv2.waitKey(1) & 0xFF == ord("q"):
            break

    cap.release()
    cv2.destroyAllWindows()

# ---------------- MAIN ----------------
def main(img_path: str):
    img_bgr = cv2.imread(img_path)
    if img_bgr is None:
        raise FileNotFoundError(f"Could not load image at {img_path}")

    preds = run_inference(img_bgr)
    result = draw_predictions(img_bgr, preds)


    cv2.imshow("Predictions", result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    # optional save
    cv2.imwrite("output.png", result)
    print("Saved result as output.png")

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--image", help="Path to input image", default=None)
    parser.add_argument("--live", action="store_true", help="Run live webcam inference")
    args = parser.parse_args()

    if args.live:
        live_inference()
    elif args.image:
        main(args.image)
